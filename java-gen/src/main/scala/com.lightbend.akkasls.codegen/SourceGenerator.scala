/*
 * Copyright (c) Lightbend Inc. 2021
 *
 */

package com.lightbend.akkasls.codegen

import com.google.common.base.Charsets
import org.bitbucket.inkytonik.kiama.output.PrettyPrinter
import org.bitbucket.inkytonik.kiama.output.PrettyPrinterTypes.Document

import java.nio.file.{ Files, Path, Paths }

/**
  * Responsible for generating Java source from an entity model
  */
object SourceGenerator extends PrettyPrinter {

  /**
    * Generate Java source from entities where the target source and test source directories have no existing source.
    * Note that we only generate tests for entities where we are successful in generating an entity. The user may
    * not want a test otherwise.
    *
    * Impure.
    *
    * @param entities        The model of entity metadata to generate source file
    * @param sourceDirectory A directory to generate source files in, which can also containing existing source.
    * @param testSourceDirectory A directory to generate test source files in, which can also containing existing source.
    * @return A collection of paths addressing source files generated by this function
    */
  def generate(
      entities: Iterable[ModelBuilder.Entity],
      sourceDirectory: Path,
      testSourceDirectory: Path
  ): Iterable[Path] =
    entities.flatMap { case entity: ModelBuilder.EventSourcedEntity =>
      val className   = entity.fullName.reverse.takeWhile(_ != '.').reverse
      val packageName = entity.fullName.dropRight(className.length + 1)
      val packagePath = Paths.get(packageName.replace(".", "/"))

      val sourcePath = sourceDirectory.resolve(packagePath.resolve(className + ".java"))
      if (!sourcePath.toFile.exists()) {
        // We're going to generate an entity - let's see if we can generate its test...
        val testClassName = className + "Test"
        val testSourcePath =
          testSourceDirectory.resolve(packagePath.resolve(testClassName + ".java"))
        val testSourceFiles = if (!testSourcePath.toFile.exists()) {
          val _ = testSourcePath.getParent.toFile.mkdirs()
          val _ = Files.write(
            testSourcePath,
            testSource(entity, packageName, className, testClassName).layout.getBytes(
              Charsets.UTF_8
            )
          )
          List(testSourcePath)
        } else {
          List.empty
        }

        // Now we generate the entity
        val _ = sourcePath.getParent.toFile.mkdirs()
        val _ = Files.write(
          sourcePath,
          source(entity, packageName, className).layout.getBytes(Charsets.UTF_8)
        )

        List(sourcePath) ++ testSourceFiles
      } else {
        List.empty
      }
    }

  /**
    * Map a test source document from an entity.
    *
    * @param entity the entity meta data
    * @param packageName the Java package to generate
    * @param className the outer Java class name to generate
    * @return the generated document
    */
  private[codegen] def source(
      entity: ModelBuilder.EventSourcedEntity,
      packageName: String,
      className: String
  ): Document =
    pretty(
      "package" <+> packageName <> semi <> line <>
      line <>
      "import" <+> "com.google.protobuf.Empty" <> semi <> line <>
      "import" <+> "io.cloudstate.javasupport.EntityId" <> semi <> line <>
      "import" <+> "io.cloudstate.javasupport.eventsourced.*" <> semi <> line <>
      line <>
      javaDoc("An event sourced entity.") <> line <>
      `annotation`("EventSourcedEntity") <> line <>
      `class`("public", className) {
        annotation("SuppressWarnings", List("unused")) <> line <>
        field(
          "private",
          "String",
          "entityId",
          `final` = true
        ) <> semi <> line <>
        line <>
        constructor(
          "public",
          className,
          List(annotation("EntityId") <+> parameter("String", "entityId"))
        ) {
          "this.entityId" <+> equal <+> "entityId" <> semi
        } <> line <>
        line <>
        ssep(
          entity.commands.toSeq.map { command =>
            annotation("CommandHandler") <>
            line <>
            method(
              "public",
              qualifiedType(command.outputType, entity.javaOuterClassname),
              lowerFirst(name(command.fullname)),
              List(
                parameter(
                  qualifiedType(command.inputType, entity.javaOuterClassname),
                  lowerFirst(name(command.inputType))
                )
              )
            ) {
              """throw new UnsupportedOperationException("Requires implementation")""" <> semi
            }
          },
          line <> line
        )
      }
    )

  /**
    * Map a test source document from an entity.
    *
    * @param entity the entity meta data
    * @param packageName the Java package to generate
    * @param className the outer Java class name to generate
    * @param testClassName the outer Java test class name to generate
    * @return the generated document
    */
  private[codegen] def testSource(
      entity: ModelBuilder.EventSourcedEntity,
      packageName: String,
      className: String,
      testClassName: String
  ): Document =
    pretty(
      "package" <+> packageName <> semi <> line <>
      line <>
      "import" <+> "io.cloudstate.javasupport.eventsourced.CommandContext" <> semi <> line <>
      "import" <+> "org.junit.Test" <> semi <> line <>
      "import" <+> "org.mockito.*" <> semi <> line <>
      line <>
      `class`("public", testClassName) {
        field(
          "private",
          "String",
          "entityId"
        ) <+> equal <+> """"entityId1"""" <> semi <> line <>
        field("private", className, "entity") <> semi <> line <>
        field(
          "private",
          "CommandContext",
          "context"
        ) <+> equal <+> "Mockito.mock(CommandContext.class)" <> semi <> line <>
        line <>
        ssep(
          entity.commands.toSeq.map { command =>
            annotation("Test") <>
            line <>
            method(
              "public",
              "void",
              lowerFirst(name(command.fullname)) + "Test",
              List.empty
            ) {
              "entity" <+> equal <+> "new MyServiceEntity(entityId)" <> semi <> line <>
              line <>
              "// entity" <> dot <> lowerFirst(name(command.fullname)) <> parens(
                name(entity.javaOuterClassname) <> dot <> name(
                  command.fullname
                ) <> dot <> "newBuilder().setEntityId(entityId).build(), context"
              ) <> semi <> line <>
              line <>
              "// Mockito.verify(context).emit(event)" <> semi
            }
          },
          line <> line
        )
      }
    )

  private def javaDoc(comment: String): Doc =
    "/**" <+> comment <+> "*/"

  private def annotation(name: String): Doc =
    annotation(name, List.empty)

  private def annotation(name: String, parameters: Seq[String]): Doc =
    "@" <> name <>
    (if (parameters.nonEmpty)
       parens(ssep(parameters.map(t => dquotes(text(t))), comma <> space))
     else
       emptyDoc)

  private def `class`(scope: String, name: String)(body: Doc): Doc =
    scope <+> "class" <+> name <+>
    braces(nest(line <> body) <> line)

  private def field(
      scope: String,
      `type`: String,
      name: String
  ): Doc =
    field(scope, `type`, name, `final` = false)

  private def field(
      scope: String,
      `type`: String,
      name: String,
      `final`: Boolean
  ): Doc =
    scope <+> (if (`final`) "final" <+> emptyDoc else emptyDoc) <> `type` <+> name

  private def constructor(
      scope: String,
      name: String,
      parameters: Seq[Doc]
  )(body: Doc): Doc =
    scope <+> name <> parens(ssep(parameters, comma <> space)) <+>
    braces(nest(line <> body) <> line)

  private def parameter(`type`: String, name: String) =
    `type` <+> name

  private def method(
      scope: String,
      returnType: String,
      name: String,
      parameters: Seq[Doc]
  )(body: Doc): Doc =
    scope <+> returnType <+> name <> parens(ssep(parameters, comma <> space)) <+>
    braces(nest(line <> body) <> line)

  private def name(`type`: String): String =
    `type`.reverse.takeWhile(_ != '.').reverse

  private def qualifiedType(`type`: String, outerClassname: String): String =
    if (`type` == "google.protobuf.Empty")
      name(`type`)
    else
      outerClassname + "." + name(`type`)

  private def lowerFirst(text: String): String =
    text.headOption match {
      case Some(c) => c.toLower.toString + text.drop(1)
      case None    => ""
    }

}
