/*
 * Copyright (c) Lightbend Inc. 2021
 *
 */

package com.lightbend.akkasls.codegen

import com.google.common.base.Charsets
import org.bitbucket.inkytonik.kiama.output.PrettyPrinter
import org.bitbucket.inkytonik.kiama.output.PrettyPrinterTypes.Document

import java.nio.file.{ Files, Path }

/**
  * Responsible for generating Java source from an entity model
  */
object SourceGenerator extends PrettyPrinter {

  /**
    * Generate Java source from entities where the target source directory has no existing source.
    *
    * Impure.
    *
    * @param entities        The model of entity metadata to generate source file
    * @param sourceDirectory A directory to generate source files in, which can also containing existing source.
    * @return A collection of paths addressing source files generated by this function
    */
  def generate(entities: Iterable[ModelBuilder.Entity], sourceDirectory: Path): Iterable[Path] =
    entities.flatMap { case entity: ModelBuilder.EventSourcedEntity =>
      val className     = entity.fullName.reverse.takeWhile(_ != '.').reverse
      val packageName   = entity.fullName.dropRight(className.length + 1)
      val sourceFileStr = packageName.replace(".", "/") + "/" + className + ".java"
      val sourcePath    = sourceDirectory.resolve(sourceFileStr)
      if (!sourcePath.toFile.exists()) {
        val _ = sourcePath.getParent.toFile.mkdirs()
        val _ = Files.write(
          sourcePath,
          source(entity, packageName, className).layout.getBytes(Charsets.UTF_8)
        )
        List(sourcePath)
      } else {
        List.empty
      }
    }

  /**
    * Map a source document from an entity.
    *
    * @param entity the entity meta data
    * @param packageName the Java package to generate
    * @param className the outer Java class name to generate
    * @return the generated document
    */
  private[codegen] def source(
      entity: ModelBuilder.EventSourcedEntity,
      packageName: String,
      className: String
  ): Document =
    pretty(
      `package`(packageName) <> line <>
      line <>
      `import`("com.google.protobuf.Empty") <> line <>
      `import`("io.cloudstate.javasupport.EntityId") <> line <>
      `import`("io.cloudstate.javasupport.eventsourced.*") <> line <>
      line <>
      javaDoc("An event sourced entity.") <> line <>
      `annotation`("EventSourcedEntity") <> line <>
      `class`("public", className) {
        annotation("SuppressWarnings", List("unused")) <> line <>
        field(
          "private",
          "String",
          "entityId",
          `final` = true
        ) <> line <>
        line <>
        constructor(
          "public",
          className,
          List(annotation("EntityId") <+> parameter("String", "entityId"))
        ) {
          assignment("this.entityId", "entityId")
        } <> line <>
        line <>
        ssep(
          entity.commands.toSeq.map { command =>
            annotation("CommandHandler") <>
            line <>
            method(
              "public",
              qualifiedType(command.outputType, entity.javaOuterClassname),
              lowerFirst(name(command.fullname)),
              List(
                parameter(
                  qualifiedType(command.inputType, entity.javaOuterClassname),
                  lowerFirst(name(command.inputType))
                )
              )
            )
          },
          line <> line
        )
      }
    )

  private def `package`(name: String): Doc =
    "package" <+> name <> semi

  private def `import`(name: String): Doc =
    "import" <+> name <> semi

  private def javaDoc(comment: String): Doc =
    "/**" <+> comment <+> "*/"

  private def annotation(name: String): Doc =
    annotation(name, List.empty)

  private def annotation(name: String, parameters: Seq[String]): Doc =
    "@" <> name <>
    (if (parameters.nonEmpty)
       parens(ssep(parameters.map(t => dquotes(text(t))), comma <> space))
     else
       emptyDoc)

  private def `class`(scope: String, name: String)(body: Doc): Doc =
    scope <+> "class" <+> name <+>
    braces(nest(line <> body, 2) <> line)

  private def field(
      scope: String,
      `type`: String,
      name: String,
      `final`: Boolean
  ): Doc =
    scope <+> (if (`final`) "final" <+> emptyDoc else emptyDoc) <> `type` <+> name <> semi

  private def constructor(
      scope: String,
      name: String,
      parameters: Seq[Doc]
  )(body: Doc): Doc =
    scope <+> name <> parens(ssep(parameters, comma <> space)) <+>
    braces(nest(line <> body, 2) <> line)

  private def parameter(`type`: String, name: String) =
    `type` <+> name

  private def assignment(lval: String, rval: String): Doc =
    lval <+> equal <+> rval <> semi

  private def method(
      scope: String,
      returnType: String,
      name: String,
      parameters: Seq[Doc]
  ): Doc =
    scope <+> returnType <+> name <> parens(ssep(parameters, comma <> space)) <+>
    braces(
      nest(
        line <> """throw new UnsupportedOperationException("Requires implementation")""" <> semi
      ) <> line
    )

  private def name(`type`: String): String =
    `type`.reverse.takeWhile(_ != '.').reverse

  private def qualifiedType(`type`: String, outerClassname: String): String =
    if (`type` == "google.protobuf.Empty")
      name(`type`)
    else
      outerClassname + "." + name(`type`)

  private def lowerFirst(text: String): String =
    text.headOption match {
      case Some(c) => c.toLower.toString + text.drop(1)
      case None    => ""
    }

}
